import pygameimport numpy as npVIEWPORT_WIDTH = 1000VIEWPORT_HEIGHT = 800DRAW_SIZE = 5GRAVITY = np.array([0, 100])sub_tick = 3SPHERE_DRAG_COEFF = 0.1DENSITY_AIR = 1class Force:    def __init__(self, force):        self.force = force    def get_force(self):        return self.force    def __str__(self):        return f"Force(force={self.force})"    def __repr__(self):        return self.__str__()GlOBAL_FORCES = (Force(GRAVITY),)class Drag(Force):    @staticmethod    def calculate_drag(velocity, density, area, drag_coeff):        # Calculate the magnitude of the drag force        speed = np.linalg.norm(velocity)  # Calculate the speed (magnitude of velocity)        drag_magnitude = 0.5 * density * speed ** 2 * area * drag_coeff        # Calculate the drag direction (opposite to velocity)        if speed == 0:            drag_direction = np.zeros_like(velocity)  # No drag if the object is not moving        else:            drag_direction = -velocity / speed  # Unit vector in the opposite direction of velocity        # Return the drag force vector        #print(drag_magnitude * drag_magnitude)        return Force(drag_direction * drag_magnitude)class Friction(Force):    @staticmethod    def calculate_friction(velocity):        return Force(velocity * 0.9 * - 1)class Camera:    @staticmethod    def world_to_viewport(pos):        return (pos[0] + VIEWPORT_WIDTH / 2, pos[1] + VIEWPORT_HEIGHT / 2)    @staticmethod    def viewport_to_world(pos):        return (pos[0] - VIEWPORT_WIDTH / 2, pos[1] - VIEWPORT_HEIGHT / 2)class Box:    def __init__(self, q1, q4):        self.q1 = q1        self.q4 = q4        self.q2 = np.array([q4[0], q1[1]])        self.q3 = np.array([q1[0], q4[1]])class OuterBox(Box):    def __init__(self, q1, q4):        super().__init__(q1, q4)    def check_collision(self, particle, spatial_partitioning=None):        if particle.pos[0] - particle.radius < self.q1[0]:            particle.change_pos_x(particle.pos[0] + particle.radius                                  - particle.pos[0], spatial_partitioning)            particle.velocity[0] *= -1        elif particle.pos[0] + particle.radius > self.q4[0]:            particle.change_pos_x(particle.pos[0] - abs(self.q4[0]                                  - particle.pos[0] - particle.radius), spatial_partitioning)            particle.velocity[0] *= -1        if particle.pos[1] - particle.radius < self.q1[1]:            particle.change_pos_y(particle.pos[1] + particle.radius                                  - particle.pos[1], spatial_partitioning)            particle.velocity[1] *= -1        elif particle.pos[1] + particle.radius > self.q4[1]:            particle.change_pos_y(particle.pos[1] + self.q4[1]                                  - particle.pos[1] - particle.radius, spatial_partitioning)            particle.velocity[1] *= -1class InnerBox(Box):    def __init__(self, q1, q4):        super().__init__(q1, q4)    def check_collision(self, particle, spatial_partitioning=None):        if particle.pos[0] + particle.radius > self.q1[0] and particle.pos[0] - particle.radius < self.q4[0] and particle.pos[1] + particle.radius > self.q1[1] and particle.pos[1] - particle.radius < self.q4[1]:            particle.change_pos_x(particle.pos[0] - self.q1[0] + particle.pos[0], spatial_partitioning)            particle.velocity[0] *= -1        elif particle.pos[0] - particle.radius < self.q4[0]:            particle.change_pos_x(self.q4[0] - particle.pos[0] + particle.pos[0], spatial_partitioning)            particle.velocity[0] *= -1        if particle.pos[1] + particle.radius > self.q1[1]:            particle.change_pos_y(particle.pos[1] - self.q1[1] + particle.pos[1], spatial_partitioning)            particle.velocity[1] *= -1        elif particle.pos[1] - particle.radius < self.q4[1]:            particle.change_pos_y(self.q4[1] - particle.pos[1] + particle.pos[1], spatial_partitioning)            particle.velocity[1] *= -1class Scene:    def __init__(self, viewport_width, viewport_height, spatial_partitioning):        self.objects = []        self.static_objects = []        self.spatial_partitioning = spatial_partitioning if spatial_partitioning else None        self.static_objects.append(OuterBox(np.array([0, 0]), np.array([viewport_width, viewport_height])))    def add_object(self, obj):        self.objects.append(obj)    def remove_object(self, obj):        self.objects.remove(obj)    def add_static_object(self, obj):        self.static_objects.append(obj)    def remove_static_object(self, obj):        self.static_objects.remove(obj)    @staticmethod    def make_particle_list(start_x, start_y, nb_elems, radius_list):        local_start_x = start_x        local_start_x_idx = 0        local_start_y = start_y        x_y = []        particle_list = []        for _, radius in zip(range(nb_elems), radius_list):            x = local_start_x + (radius * 2 * local_start_x_idx) + 5 * (local_start_x_idx)            if x >= VIEWPORT_WIDTH - radius:                local_start_x_idx = 0                local_start_x = start_x                local_start_y += radius * 2 + radius            x_y.append(np.array([np.float64(local_start_x + (radius * 2 * local_start_x_idx) + 5 * local_start_x_idx), np.float64(local_start_y)]))            particle_list.append(Particle(x_y[-1], np.float64(radius), 6 + 6 * np.random.rand(1, 2)[0]))            local_start_x_idx += 1        return particle_list    def check_collision(self, particle):        for obj in self.static_objects:            if isinstance(obj, Box):                obj.check_collision(particle, self.spatial_partitioning)        if self.spatial_partitioning:            self.spatial_partitioning.check_collision(particle)    def simulate(self, delta_time):        for particle in self.objects:            if isinstance(particle, Particle):                self.check_collision(particle)                particle.update_particle(delta_time, self.spatial_partitioning)class Particle:    def __init__(self, pos, radius, velocity):        self.idx = None        self.pos = pos        self.radius = radius        self.velocity = velocity        self.color = np.random.randint(50, 255, size=(1, 3))[0]    def __str__(self):        return f"Particle(pos={self.pos}, radius={self.radius}, velocity={self.velocity})"    def __repr__(self):        return self.__str__()    def kinetic_energy(self):        return abs(0.5 * (self.velocity[0] ** 2 + self.velocity[1] ** 2))    def potential_energy(self):        return GRAVITY[1] * (VIEWPORT_HEIGHT - self.pos[1] - self.radius)    def get_area(self):        return np.pi * self.radius ** 2    def elastic_collision(self, particle):        pos_diff = self.pos - particle.pos        vel_diff = self.velocity - particle.velocity        distance_squared = np.dot(pos_diff, pos_diff)        velocity_change = np.dot(vel_diff, pos_diff) / distance_squared * pos_diff        self.velocity -= velocity_change        particle.velocity += velocity_change    def change_pos(self, pos, accel_struct):        if accel_struct:            accel_struct.remove_particle(self)        self.pos = pos        if accel_struct:            accel_struct.add_particle(self)    def change_pos_x(self, pos_x, accel_struct):        if accel_struct:            accel_struct.remove_particle(self)        self.pos[0] = pos_x        if accel_struct:            accel_struct.add_particle(self)    def change_pos_y(self, pos_y, accel_struct):        if accel_struct:            accel_struct.remove_particle(self)        self.pos[1] = pos_y        if accel_struct:            accel_struct.add_particle(self)    def update_particle(self, delta_time, accel_struct=None):        # Calculate local forces like drag and friction        local_global_forces = []        #local_global_forces.append(Friction.calculate_friction(self.velocity))        for force in GlOBAL_FORCES + tuple(local_global_forces):            self.velocity += force.get_force() * delta_time        # Check if velocity is below a very low threshold and stop movement        if np.all(np.abs(self.velocity) < 0.3):            self.velocity = np.zeros_like(self.velocity)        # Update position based on velocity        delta_pos = self.velocity * delta_time        self.change_pos(self.pos + delta_pos, accel_struct)    def check_collision(self, particle, grid):        if particle == self:            return        delta_pos = self.pos - particle.pos        distance = np.linalg.norm(self.pos - particle.pos)        sum_radius = self.radius + particle.radius        if distance < sum_radius:            overlap_distance = sum_radius - distance            if distance == 0:                direction = np.array([1, 0])            else:                direction = delta_pos / distance            displacement = direction * (overlap_distance / 2)            self.change_pos(self.pos + displacement, grid)            particle.change_pos(particle.pos - displacement, grid)            self.elastic_collision(particle)class Cell:    def __init__(self, q1, q4):        self.q1 = q1        self.q4 = q4        self.q2 = np.array([q4[0], q1[1]])        self.q3 = np.array([q1[0], q4[1]])        self.particles = []    def __str__(self):        return f"Cell(q1={self.q1}, q4={self.q4})"    def __repr__(self):        return self.__str__()    def add_particle(self, particle):        self.particles.append(particle)    def remove_particle(self, particle):        self.particles.remove(particle)class Grid:    def __init__(self, q1, q4, cell_size):        self.q1 = q1        self.q4 = q4        self.cell_size = cell_size        self.cells = []        self.create_cells()    def create_cells(self):        for cell_idx in range(self.q1[0], self.q4[0], self.cell_size):            row = []            for cell_idy in range(self.q1[1], self.q4[1], self.cell_size):                row.append(Cell(np.array([cell_idx, cell_idy]), np.array([cell_idx + self.cell_size, cell_idy + self.cell_size])))            self.cells.append(row)    def get_cell(self, pos):        pos_x = max(0, pos[0] // self.cell_size)        pos_y = max(0, pos[1] // self.cell_size)        if pos_x >= len(self.cells):            pos_x = len(self.cells) - 1        if pos_y >= len(self.cells[0]):            pos_y = len(self.cells[0]) - 1        if pos_x <= len(self.cells) and pos_y <= len(self.cells[0]):            return self.cells[int(pos_x)][int(pos_y)]        return None    def get_cell_idx(self, pos):        pos_x = max(0, pos[0] // self.cell_size)        pos_y = max(0, pos[1] // self.cell_size)        if pos_x >= len(self.cells):            pos_x = len(self.cells) - 1        if pos_y >= len(self.cells[0]):            pos_y = len(self.cells[0]) - 1        if pos_x < len(self.cells) and pos_y < len(self.cells[0]):            return (int(pos_x), int(pos_y))        return (None, None)    def add_particle(self, particle):        self.get_cell(particle.pos).add_particle(particle)    def remove_particle(self, particle):        self.get_cell(particle.pos).remove_particle(particle)    def get_neighbour_cells(self, particle):        cell_x, cell_y = self.get_cell_idx(particle.pos)        if cell_x != None and cell_y != None and cell_x > 0 and cell_y > 0 and cell_x < len(self.cells) - 1 and cell_y < len(self.cells[0]) - 1:            return [                self.cells[cell_x - 1][cell_y - 1],                self.cells[cell_x - 1][cell_y],                self.cells[cell_x - 1][cell_y + 1],                self.cells[cell_x][cell_y - 1],                self.cells[cell_x][cell_y],                self.cells[cell_x][cell_y + 1],                self.cells[cell_x + 1][cell_y - 1],                self.cells[cell_x + 1][cell_y],                self.cells[cell_x + 1][cell_y + 1]            ]        return []    def propagate_particle(self, particle):        self.add_particle(particle)    def check_collision(self, particle):        for neighbour in self.get_neighbour_cells(particle):            for other_particle in neighbour.particles:                particle.check_collision(other_particle, self)if __name__ == "__main__":    # pygame setup    pygame.init()    screen = pygame.display.set_mode((VIEWPORT_WIDTH, VIEWPORT_HEIGHT))    running = True    dt = 0    particle_count = 1000    start_x, start_y = Camera.viewport_to_world((10, 10))    #particle_list = Scene.make_particle_list(300, 0, particle_count, np.random.randint(3, 10, particle_count))    particle_list = Scene.make_particle_list(300, 0, particle_count, particle_count * [5])    grid = Grid(np.array([0, 0]), np.array([VIEWPORT_WIDTH, VIEWPORT_HEIGHT]), 3)    scene = Scene(VIEWPORT_WIDTH, VIEWPORT_HEIGHT, grid)    for particle in particle_list:        scene.add_object(particle)        grid.propagate_particle(particle)    clock = pygame.time.Clock()    while running:        start_time = pygame.time.get_ticks()        for event in pygame.event.get():            if event.type == pygame.QUIT:                running = False        screen.fill("black")        for _ in range(sub_tick):            scene.simulate(dt / sub_tick)        for particle in scene.objects:            if isinstance(particle, Particle):                pygame.draw.circle(screen, particle.color, particle.pos, particle.radius)        pygame.display.flip()        dt = clock.tick() / 1000.        end_time = pygame.time.get_ticks()        #print(f"FPS: {1000. / (end_time - start_time)}")    pygame.quit()